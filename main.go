package main

import (
	"bytes"
	"encoding/hex"
	"fmt"

	"github.com/gcash/bchd/bchec"
	"github.com/gcash/bchd/chaincfg/chainhash"
	"github.com/gcash/bchd/txscript"
	"github.com/gcash/bchd/wire"
	"github.com/gcash/bchutil"
)

var shaGateScriptHash = [20]byte{1}           //todo: generated by covenant
var prevOutputAmount int64 = 1                //todo: balance of p2sh of input pk script
var outputAmount int64 = 1                    //todo: pre p2sh address balance - fee
var operatorPubkeys [3]*bchutil.AddressPubKey //todo: now just set operators 2-3, modify it
var operatorKeys [3]*bchec.PrivateKey         //todo: operator private keys

func signP2shTx() (string, error) {
	tx := wire.NewMsgTx(wire.TxVersion)
	// 1. build tx output
	pkScript, err := buildP2shPubkeyScript(shaGateScriptHash[:])
	if err != nil {
		panic(err)
	}
	tx.AddTxOut(wire.NewTxOut(outputAmount, pkScript))
	// 2. build tx input
	in := wire.TxIn{
		PreviousOutPoint: wire.OutPoint{
			Hash:  chainhash.Hash{}, //todo: get from walled db by p2sh address in prev pubkeyScript
			Index: 0,
		},
		SignatureScript: nil,
		Sequence:        0xffffffff,
	}
	tx.AddTxIn(&in)
	// 3. build redeemScript
	redeemScript, err := buildMultiSigRedeemScript(operatorPubkeys[:], 2)
	if err != nil {
		panic(err)
	}
	// 4. sign
	sig1, err := txscript.RawTxInECDSASignature(tx, 0, redeemScript, txscript.SigHashAll, operatorKeys[0], prevOutputAmount)
	if err != nil {
		panic(err)
	}
	sig2, err := txscript.RawTxInECDSASignature(tx, 0, redeemScript, txscript.SigHashAll, operatorKeys[1], prevOutputAmount)
	if err != nil {
		panic(err)
	}
	signatureScript, err := txscript.NewScriptBuilder().AddData(sig1).AddData(sig2).AddData(redeemScript).Script()
	if err != nil {
		panic(err)
	}
	in.SignatureScript = signatureScript
	// 5. serialize
	return txSerialize2Hex(tx), nil
}

func buildP2shPubkeyScript(scriptHash []byte) ([]byte, error) {
	return txscript.NewScriptBuilder().AddOp(txscript.OP_HASH160).AddData(scriptHash).AddOp(txscript.OP_EQUAL).Script()
}

func buildMultiSigRedeemScript(pubkeys []*bchutil.AddressPubKey, n int) ([]byte, error) {
	return txscript.MultiSigScript(pubkeys, n)
}

func txSerialize2Hex(tx *wire.MsgTx) string {
	buf := bytes.NewBuffer(make([]byte, 0, tx.SerializeSize()))
	if err := tx.Serialize(buf); err != nil {
		panic(err)
	}
	return hex.EncodeToString(buf.Bytes())
}

func main() {
	hexTx, err := signP2shTx()
	if err != nil {
		panic(err)
	}
	fmt.Println(hexTx)
}
